// Code generated by protoc-gen-go.
// source: exeggutor.proto
// DO NOT EDIT!

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	exeggutor.proto

It has these top-level messages:
	StringKeyValue
	StringIntKeyValue
	ApplicationComponent
	ApplicationManifest
	ScheduledAppComponent
	HealthCheck
	ApplicationSLA
*/
package protocol

import proto "code.google.com/p/goprotobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

//
// AppStatus is used to indicate where an app is in a lifecycle on the cluster
type AppStatus int32

const (
	// AppStatus_ABSENT the application has no running instances
	AppStatus_ABSENT AppStatus = 1
	// AppStatus_DEPLOYING the application is currently being deployed
	AppStatus_DEPLOYING AppStatus = 2
	// AppStatus_STOPPED the application has been stopped
	AppStatus_STOPPED AppStatus = 3
	// AppStatus_STOPPING the application has is stopping, a command was issued to stop the app
	AppStatus_STOPPING AppStatus = 4
	// AppStatus_STARTING the application has been deployed and is currently starting up
	AppStatus_STARTING AppStatus = 5
	// AppStatus_STARTED the application is fully available for taking requests
	AppStatus_STARTED AppStatus = 6
	// AppStatus_VERY_BUSY the application is still up but timing out very often, best to avoid it for a while
	AppStatus_VERY_BUSY AppStatus = 7
	// AppStatus_UNHEALTHY the application has a running process but is otherwise broken, don't send requests here
	AppStatus_UNHEALTHY AppStatus = 8
)

var AppStatus_name = map[int32]string{
	1: "ABSENT",
	2: "DEPLOYING",
	3: "STOPPED",
	4: "STOPPING",
	5: "STARTING",
	6: "STARTED",
	7: "VERY_BUSY",
	8: "UNHEALTHY",
}
var AppStatus_value = map[string]int32{
	"ABSENT":    1,
	"DEPLOYING": 2,
	"STOPPED":   3,
	"STOPPING":  4,
	"STARTING":  5,
	"STARTED":   6,
	"VERY_BUSY": 7,
	"UNHEALTHY": 8,
}

func (x AppStatus) Enum() *AppStatus {
	p := new(AppStatus)
	*p = x
	return p
}
func (x AppStatus) String() string {
	return proto.EnumName(AppStatus_name, int32(x))
}
func (x *AppStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AppStatus_value, data, "AppStatus")
	if err != nil {
		return err
	}
	*x = AppStatus(value)
	return nil
}

//
// ComponentType is used to describe what type of service this is.
// This is used for determining montitoring strategy and so on.
// It might also influence the way an application is deployed
type ComponentType int32

const (
	// ComponentType_SERVICE A long-running service
	ComponentType_SERVICE ComponentType = 0
	// ComponentType_TASK A short one-off task
	ComponentType_TASK ComponentType = 1
	// ComponentType_CRON A task scheduled to repeat on a schedule or to be executed at a later, scheduled time
	ComponentType_CRON ComponentType = 2
	// ComponentType_SPARK_JOB A spark job
	ComponentType_SPARK_JOB ComponentType = 3
)

var ComponentType_name = map[int32]string{
	0: "SERVICE",
	1: "TASK",
	2: "CRON",
	3: "SPARK_JOB",
}
var ComponentType_value = map[string]int32{
	"SERVICE":   0,
	"TASK":      1,
	"CRON":      2,
	"SPARK_JOB": 3,
}

func (x ComponentType) Enum() *ComponentType {
	p := new(ComponentType)
	*p = x
	return p
}
func (x ComponentType) String() string {
	return proto.EnumName(ComponentType_name, int32(x))
}
func (x *ComponentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ComponentType_value, data, "ComponentType")
	if err != nil {
		return err
	}
	*x = ComponentType(value)
	return nil
}

//
// Distribution is used to decide how an application should be deployed
// This determines whether it needs extraction etc.
type Distribution int32

const (
	// Distributed as a package for the OS package manager (RPM, DEB, ...)
	// This implies that a docker container will be created ad-hoc to install this package.
	// It's probably better to get jenkins to build a proper docker container for your application.
	Distribution_PACKAGE Distribution = 0
	// Distributed as a Docker Container
	Distribution_DOCKER Distribution = 1
	// Ad-Hoc script, fat-jar, single-binary
	Distribution_SCRIPT Distribution = 2
	// Distributed as executable jar
	Distribution_FAT_JAR Distribution = 3
)

var Distribution_name = map[int32]string{
	0: "PACKAGE",
	1: "DOCKER",
	2: "SCRIPT",
	3: "FAT_JAR",
}
var Distribution_value = map[string]int32{
	"PACKAGE": 0,
	"DOCKER":  1,
	"SCRIPT":  2,
	"FAT_JAR": 3,
}

func (x Distribution) Enum() *Distribution {
	p := new(Distribution)
	*p = x
	return p
}
func (x Distribution) String() string {
	return proto.EnumName(Distribution_name, int32(x))
}
func (x *Distribution) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Distribution_value, data, "Distribution")
	if err != nil {
		return err
	}
	*x = Distribution(value)
	return nil
}

type HealthCheck_HealthCheckMode int32

const (
	HealthCheck_REST HealthCheck_HealthCheckMode = 0
	HealthCheck_TCP  HealthCheck_HealthCheckMode = 1
)

var HealthCheck_HealthCheckMode_name = map[int32]string{
	0: "REST",
	1: "TCP",
}
var HealthCheck_HealthCheckMode_value = map[string]int32{
	"REST": 0,
	"TCP":  1,
}

func (x HealthCheck_HealthCheckMode) Enum() *HealthCheck_HealthCheckMode {
	p := new(HealthCheck_HealthCheckMode)
	*p = x
	return p
}
func (x HealthCheck_HealthCheckMode) String() string {
	return proto.EnumName(HealthCheck_HealthCheckMode_name, int32(x))
}
func (x *HealthCheck_HealthCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HealthCheck_HealthCheckMode_value, data, "HealthCheck_HealthCheckMode")
	if err != nil {
		return err
	}
	*x = HealthCheck_HealthCheckMode(value)
	return nil
}

// StringKeyValue represents a pair of 2 strings used as a replacement for maps
type StringKeyValue struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StringKeyValue) Reset()         { *m = StringKeyValue{} }
func (m *StringKeyValue) String() string { return proto.CompactTextString(m) }
func (*StringKeyValue) ProtoMessage()    {}

func (m *StringKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringKeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// StringIntKeyValue represents a pair of string to int, used as a replacement for maps
type StringIntKeyValue struct {
	// Key the key of this pair
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// Value the value of this pair
	Value            *int32 `protobuf:"varint,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StringIntKeyValue) Reset()         { *m = StringIntKeyValue{} }
func (m *StringIntKeyValue) String() string { return proto.CompactTextString(m) }
func (*StringIntKeyValue) ProtoMessage()    {}

func (m *StringIntKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringIntKeyValue) GetValue() int32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

//
// ApplicationComponent is a part of what makes up a single application.
// It describes the packaging and distribution model of the component
// It also describes the requirements for the component in terms of disk space, cpu and memory
// Furthermore it contains the configuration for the environment and scheme to port mapping
// It also has a status field to track the deployment status of this component
type ApplicationComponent struct {
	Name             *string              `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Cpus             *float32             `protobuf:"fixed32,2,req,name=cpus" json:"cpus,omitempty"`
	Mem              *float32             `protobuf:"fixed32,3,req,name=mem" json:"mem,omitempty"`
	DiskSpace        *int64               `protobuf:"varint,4,req,name=disk_space" json:"disk_space,omitempty"`
	DistUrl          *string              `protobuf:"bytes,5,req,name=dist_url" json:"dist_url,omitempty"`
	Command          *string              `protobuf:"bytes,6,req,name=command" json:"command,omitempty"`
	Env              []*StringKeyValue    `protobuf:"bytes,7,rep,name=env" json:"env,omitempty"`
	Ports            []*StringIntKeyValue `protobuf:"bytes,8,rep,name=ports" json:"ports,omitempty"`
	Version          *string              `protobuf:"bytes,9,req,name=version" json:"version,omitempty"`
	Status           *AppStatus           `protobuf:"varint,10,req,name=status,enum=protocol.AppStatus,def=1" json:"status,omitempty"`
	LogDir           *string              `protobuf:"bytes,11,opt,name=log_dir" json:"log_dir,omitempty"`
	WorkDir          *string              `protobuf:"bytes,12,opt,name=work_dir" json:"work_dir,omitempty"`
	ConfDir          *string              `protobuf:"bytes,13,opt,name=conf_dir" json:"conf_dir,omitempty"`
	Distribution     *Distribution        `protobuf:"varint,14,req,name=distribution,enum=protocol.Distribution,def=0" json:"distribution,omitempty"`
	ComponentType    *ComponentType       `protobuf:"varint,15,req,name=component_type,enum=protocol.ComponentType,def=0" json:"component_type,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *ApplicationComponent) Reset()         { *m = ApplicationComponent{} }
func (m *ApplicationComponent) String() string { return proto.CompactTextString(m) }
func (*ApplicationComponent) ProtoMessage()    {}

const Default_ApplicationComponent_Status AppStatus = AppStatus_ABSENT
const Default_ApplicationComponent_Distribution Distribution = Distribution_PACKAGE
const Default_ApplicationComponent_ComponentType ComponentType = ComponentType_SERVICE

func (m *ApplicationComponent) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ApplicationComponent) GetCpus() float32 {
	if m != nil && m.Cpus != nil {
		return *m.Cpus
	}
	return 0
}

func (m *ApplicationComponent) GetMem() float32 {
	if m != nil && m.Mem != nil {
		return *m.Mem
	}
	return 0
}

func (m *ApplicationComponent) GetDiskSpace() int64 {
	if m != nil && m.DiskSpace != nil {
		return *m.DiskSpace
	}
	return 0
}

func (m *ApplicationComponent) GetDistUrl() string {
	if m != nil && m.DistUrl != nil {
		return *m.DistUrl
	}
	return ""
}

func (m *ApplicationComponent) GetCommand() string {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return ""
}

func (m *ApplicationComponent) GetEnv() []*StringKeyValue {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *ApplicationComponent) GetPorts() []*StringIntKeyValue {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ApplicationComponent) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ApplicationComponent) GetStatus() AppStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_ApplicationComponent_Status
}

func (m *ApplicationComponent) GetLogDir() string {
	if m != nil && m.LogDir != nil {
		return *m.LogDir
	}
	return ""
}

func (m *ApplicationComponent) GetWorkDir() string {
	if m != nil && m.WorkDir != nil {
		return *m.WorkDir
	}
	return ""
}

func (m *ApplicationComponent) GetConfDir() string {
	if m != nil && m.ConfDir != nil {
		return *m.ConfDir
	}
	return ""
}

func (m *ApplicationComponent) GetDistribution() Distribution {
	if m != nil && m.Distribution != nil {
		return *m.Distribution
	}
	return Default_ApplicationComponent_Distribution
}

func (m *ApplicationComponent) GetComponentType() ComponentType {
	if m != nil && m.ComponentType != nil {
		return *m.ComponentType
	}
	return Default_ApplicationComponent_ComponentType
}

//
// ApplicationManifest gives an application a name and contains the various
// components that make up an application, like nginx, service, cron jobs
type ApplicationManifest struct {
	Name             *string                 `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Components       []*ApplicationComponent `protobuf:"bytes,2,rep,name=components" json:"components,omitempty"`
	Status           *AppStatus              `protobuf:"varint,3,opt,name=status,enum=protocol.AppStatus,def=1" json:"status,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ApplicationManifest) Reset()         { *m = ApplicationManifest{} }
func (m *ApplicationManifest) String() string { return proto.CompactTextString(m) }
func (*ApplicationManifest) ProtoMessage()    {}

const Default_ApplicationManifest_Status AppStatus = AppStatus_ABSENT

func (m *ApplicationManifest) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ApplicationManifest) GetComponents() []*ApplicationComponent {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *ApplicationManifest) GetStatus() AppStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_ApplicationManifest_Status
}

//
// ScheduledAppComponent a structure to describe an application
// component that has been scheduled for deployment.
type ScheduledAppComponent struct {
	// Id the id of the scheduled component (for retrieval from persistence medium for example)
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// Name the name of the component
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// AppName the name of the app this component belongs to
	AppName *string `protobuf:"bytes,3,req,name=app_name" json:"app_name,omitempty"`
	// Component the full component that has been scheduled
	Component *ApplicationComponent `protobuf:"bytes,4,req,name=component" json:"component,omitempty"`
	// Position the full position of this item in the queue
	Position *int32 `protobuf:"varint,5,req,name=position" json:"position,omitempty"`
	// Since the timestamp in nanoseconds when this item was added to the queue
	Since            *int64 `protobuf:"varint,6,req,name=since" json:"since,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ScheduledAppComponent) Reset()         { *m = ScheduledAppComponent{} }
func (m *ScheduledAppComponent) String() string { return proto.CompactTextString(m) }
func (*ScheduledAppComponent) ProtoMessage()    {}

func (m *ScheduledAppComponent) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ScheduledAppComponent) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ScheduledAppComponent) GetAppName() string {
	if m != nil && m.AppName != nil {
		return *m.AppName
	}
	return ""
}

func (m *ScheduledAppComponent) GetComponent() *ApplicationComponent {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *ScheduledAppComponent) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

func (m *ScheduledAppComponent) GetSince() int64 {
	if m != nil && m.Since != nil {
		return *m.Since
	}
	return 0
}

//
// HealthCheck
type HealthCheck struct {
	Mode             *HealthCheck_HealthCheckMode `protobuf:"varint,1,req,name=mode,enum=protocol.HealthCheck_HealthCheckMode,def=0" json:"mode,omitempty"`
	Host             *string                      `protobuf:"bytes,2,req,name=host" json:"host,omitempty"`
	Port             *int32                       `protobuf:"varint,3,req,name=port" json:"port,omitempty"`
	IntervalMillis   *int64                       `protobuf:"varint,4,req,name=interval_millis" json:"interval_millis,omitempty"`
	Path             *string                      `protobuf:"bytes,10,opt,name=path,def=/api/api-docs" json:"path,omitempty"`
	Scheme           *string                      `protobuf:"bytes,11,opt,name=scheme,def=http" json:"scheme,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}

const Default_HealthCheck_Mode HealthCheck_HealthCheckMode = HealthCheck_REST
const Default_HealthCheck_Path string = "/api/api-docs"
const Default_HealthCheck_Scheme string = "http"

func (m *HealthCheck) GetMode() HealthCheck_HealthCheckMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_HealthCheck_Mode
}

func (m *HealthCheck) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *HealthCheck) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *HealthCheck) GetIntervalMillis() int64 {
	if m != nil && m.IntervalMillis != nil {
		return *m.IntervalMillis
	}
	return 0
}

func (m *HealthCheck) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return Default_HealthCheck_Path
}

func (m *HealthCheck) GetScheme() string {
	if m != nil && m.Scheme != nil {
		return *m.Scheme
	}
	return Default_HealthCheck_Scheme
}

//
// ApplicationSLA
type ApplicationSLA struct {
	Instances        *int32       `protobuf:"varint,1,req,name=instances,def=1" json:"instances,omitempty"`
	HealthCheck      *HealthCheck `protobuf:"bytes,2,req,name=health_check" json:"health_check,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ApplicationSLA) Reset()         { *m = ApplicationSLA{} }
func (m *ApplicationSLA) String() string { return proto.CompactTextString(m) }
func (*ApplicationSLA) ProtoMessage()    {}

const Default_ApplicationSLA_Instances int32 = 1

func (m *ApplicationSLA) GetInstances() int32 {
	if m != nil && m.Instances != nil {
		return *m.Instances
	}
	return Default_ApplicationSLA_Instances
}

func (m *ApplicationSLA) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func init() {
	proto.RegisterEnum("protocol.AppStatus", AppStatus_name, AppStatus_value)
	proto.RegisterEnum("protocol.ComponentType", ComponentType_name, ComponentType_value)
	proto.RegisterEnum("protocol.Distribution", Distribution_name, Distribution_value)
	proto.RegisterEnum("protocol.HealthCheck_HealthCheckMode", HealthCheck_HealthCheckMode_name, HealthCheck_HealthCheckMode_value)
}
